/**
 * @generated
 * @jsx React.DOM
 */
var React = require("React");
var layout = require("AutodocsLayout");
var content = `\{
  "methods": [
    \{
      "line": 158,
      "source": "_initializeGestureState: function(gestureState) \{\\n    gestureState.moveX = 0;\\n    gestureState.moveY = 0;\\n    gestureState.x0 = 0;\\n    gestureState.y0 = 0;\\n    gestureState.dx = 0;\\n    gestureState.dy = 0;\\n    gestureState.vx = 0;\\n    gestureState.vy = 0;\\n    gestureState.numberActiveTouches = 0;\\n    // All \`gestureState\` accounts for timeStamps up until:\\n    gestureState._accountsForMovesUpTo = 0;\\n  }",
      "docblock": "/**\\n   *\\n   * A graphical explanation of the touch data flow:\\n   *\\n   * +----------------------------+             +--------------------------------+\\n   * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\\n   * +----------------------------+             +----------+---------------------+\\n   * |Global store of touchHistory|             |Allocation-less math util       |\\n   * |including activeness, start |             |on touch history (centroids     |\\n   * |position, prev/cur position.|             |and multitouch movement etc)    |\\n   * |                            |             |                                |\\n   * +----^-----------------------+             +----^---------------------------+\\n   *      |                                          |\\n   *      | (records relevant history                |\\n   *      |  of touches relevant for                 |\\n   *      |  implementing higher level               |\\n   *      |  gestures)                               |\\n   *      |                                          |\\n   * +----+-----------------------+             +----|---------------------------+\\n   * | ResponderEventPlugin       |             |    |   Your App/Component      |\\n   * +----------------------------+             +----|---------------------------+\\n   * |Negotiates which view gets  | Low level   |    |             High level    |\\n   * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\\n   * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\\n   * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\\n   * +----------------------------+ attached to |  |         |     distance and  |\\n   *                                 each event |  +---------+     velocity.     |\\n   *                                            |                                |\\n   *                                            |                                |\\n   *                                            +--------------------------------+\\n   *\\n   *\\n   *\\n   * Gesture that calculates cumulative movement over time in a way that just\\n   * \\"does the right thing\\" for multiple touches. The \\"right thing\\" is very\\n   * nuanced. When moving two touches in opposite directions, the cumulative\\n   * distance is zero in each dimension. When two touches move in parallel five\\n   * pixels in the same direction, the cumulative distance is five, not ten. If\\n   * two touches start, one moves five in a direction, then stops and the other\\n   * touch moves fives in the same direction, the cumulative distance is ten.\\n   *\\n   * This logic requires a kind of processing of time \\"clusters\\" of touch events\\n   * so that two touch moves that essentially occur in parallel but move every\\n   * other frame respectively, are considered part of the same movement.\\n   *\\n   * Explanation of some of the non-obvious fields:\\n   *\\n   * - moveX/moveY: If no move event has been observed, then \`(moveX, moveY)\` is\\n   *   invalid. If a move event has been observed, \`(moveX, moveY)\` is the\\n   *   centroid of the most recently moved \\"cluster\\" of active touches.\\n   *   (Currently all move have the same timeStamp, but later we should add some\\n   *   threshold for what is considered to be \\"moving\\"). If a palm is\\n   *   accidentally counted as a touch, but a finger is moving greatly, the palm\\n   *   will move slightly, but we only want to count the single moving touch.\\n   * - x0/y0: Centroid location (non-cumulative) at the time of becoming\\n   *   responder.\\n   * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch\\n   *   distance. Accounts for touch moves that are clustered together in time,\\n   *   moving the same direction. Only valid when currently responder (otherwise,\\n   *   it only represents the drag distance below the threshold).\\n   * - vx/vy: Velocity.\\n   */\\n",
      "modifiers": [
        "static"
      ],
      "params": [
        \{
          "typehint": null,
          "name": "gestureState"
        }
      ],
      "tparams": null,
      "returntypehint": null,
      "name": "_initializeGestureState"
    },
    \{
      "line": 196,
      "source": "_updateGestureStateOnMove: function(gestureState, touchHistory) \{\\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n    gestureState.moveX = currentCentroidXOfTouchesChangedAfter(\\n      touchHistory,\\n      gestureState._accountsForMovesUpTo\\n    );\\n    gestureState.moveY = currentCentroidYOfTouchesChangedAfter(\\n      touchHistory,\\n      gestureState._accountsForMovesUpTo\\n    );\\n    var movedAfter = gestureState._accountsForMovesUpTo;\\n    var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\\n    var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\\n    var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\\n    var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\\n    var nextDX = gestureState.dx + (x - prevX);\\n    var nextDY = gestureState.dy + (y - prevY);\\n\\n    // TODO: This must be filtered intelligently.\\n    var dt =\\n      (touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo);\\n    gestureState.vx = (nextDX - gestureState.dx) / dt;\\n    gestureState.vy = (nextDY - gestureState.dy) / dt;\\n\\n    gestureState.dx = nextDX;\\n    gestureState.dy = nextDY;\\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\\n  }",
      "docblock": "/**\\n   * This is nuanced and is necessary. It is incorrect to continuously take all\\n   * active *and* recently moved touches, find the centroid, and track how that\\n   * result changes over time. Instead, we must take all recently moved\\n   * touches, and calculate how the centroid has changed just for those\\n   * recently moved touches, and append that change to an accumulator. This is\\n   * to (at least) handle the case where the user is moving three fingers, and\\n   * then one of the fingers stops but the other two continue.\\n   *\\n   * This is very different than taking all of the recently moved touches and\\n   * storing their centroid as \`dx/dy\`. For correctness, we must *accumulate\\n   * changes* in the centroid of recently moved touches.\\n   *\\n   * There is also some nuance with how we handle multiple moved touches in a\\n   * single event. With the way \`ReactIOSEventEmitter\` dispatches touches as\\n   * individual events, multiple touches generate two 'move' events, each of\\n   * them triggering \`onResponderMove\`. But with the way \`PanResponder\` works,\\n   * all of the gesture inference is performed on the first dispatch, since it\\n   * looks at all of the touches (even the ones for which there hasn't been a\\n   * native dispatch yet). Therefore, \`PanResponder\` does not call\\n   * \`onResponderMove\` passed the first dispatch. This diverges from the\\n   * typical responder callback pattern (without using \`PanResponder\`), but\\n   * avoids more dispatches than necessary.\\n   */\\n",
      "modifiers": [
        "static"
      ],
      "params": [
        \{
          "typehint": null,
          "name": "gestureState"
        },
        \{
          "typehint": null,
          "name": "touchHistory"
        }
      ],
      "tparams": null,
      "returntypehint": null,
      "name": "_updateGestureStateOnMove"
    },
    \{
      "line": 256,
      "source": "create: function(config) \{\\n    var gestureState = \{\\n      // Useful for debugging\\n      stateID: Math.random(),\\n    };\\n    PanResponder._initializeGestureState(gestureState);\\n    var panHandlers = \{\\n      onStartShouldSetResponder: function(e) \{\\n        return config.onStartShouldSetPanResponder === undefined ? false :\\n          config.onStartShouldSetPanResponder(e, gestureState);\\n      },\\n      onMoveShouldSetResponder: function(e) \{\\n        return config.onMoveShouldSetPanResponder === undefined ? false :\\n          config.onMoveShouldSetPanResponder(e, gestureState);\\n      },\\n      onStartShouldSetResponderCapture: function(e) \{\\n        // TODO: Actually, we should reinitialize the state any time\\n        // touches.length increases from 0 active to > 0 active.\\n        if (e.nativeEvent.touches.length === 1) \{\\n          PanResponder._initializeGestureState(gestureState);\\n        }\\n        gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\\n        return config.onStartShouldSetPanResponderCapture !== undefined ?\\n          config.onStartShouldSetPanResponderCapture(e, gestureState) : false;\\n      },\\n\\n      onMoveShouldSetResponderCapture: function(e) \{\\n        var touchHistory = e.touchHistory;\\n        // Responder system incorrectly dispatches should* to current responder\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return false;\\n        }\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        return config.onMoveShouldSetResponderCapture ?\\n          config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;\\n      },\\n\\n      onResponderGrant: function(e) \{\\n        gestureState.x0 = currentCentroidX(e.touchHistory);\\n        gestureState.y0 = currentCentroidY(e.touchHistory);\\n        gestureState.dx = 0;\\n        gestureState.dy = 0;\\n        config.onPanResponderGrant && config.onPanResponderGrant(e, gestureState);\\n      },\\n\\n      onResponderReject: function(e) \{\\n        config.onPanResponderReject && config.onPanResponderReject(e, gestureState);\\n      },\\n\\n      onResponderRelease: function(e) \{\\n        config.onPanResponderRelease && config.onPanResponderRelease(e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderStart: function(e) \{\\n        var touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        config.onPanResponderStart && config.onPanResponderStart(e, gestureState);\\n      },\\n\\n      onResponderMove: function(e) \{\\n        var touchHistory = e.touchHistory;\\n        // Guard against the dispatch of two touch moves when there are two\\n        // simultaneously changed touches.\\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) \{\\n          return;\\n        }\\n        // Filter out any touch moves past the first one - we would have\\n        // already processed multi-touch geometry during the first event.\\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\\n        config.onPanResponderMove && config.onPanResponderMove(e, gestureState);\\n      },\\n\\n      onResponderEnd: function(e) \{\\n        var touchHistory = e.touchHistory;\\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\\n        config.onPanResponderEnd && config.onPanResponderEnd(e, gestureState);\\n      },\\n\\n      onResponderTerminate: function(e) \{\\n        config.onPanResponderTerminate &&\\n          config.onPanResponderTerminate(e, gestureState);\\n        PanResponder._initializeGestureState(gestureState);\\n      },\\n\\n      onResponderTerminationRequest: function(e) \{\\n        return config.onPanResponderTerminationRequest === undefined ? true :\\n          config.onPanResponderTerminationRequest(e, gestureState);\\n      },\\n    };\\n    return \{panHandlers: panHandlers};\\n  }",
      "docblock": "/**\\n   * @param \{object} config Enhanced versions of all of the responder callbacks\\n   * that provide not only the typical \`ResponderSyntheticEvent\`, but also the\\n   * \`PanResponder\` gesture state.  Simply replace the word \`Responder\` with\\n   * \`PanResponder\` in each of the typical \`onResponder*\` callbacks. For\\n   * example, the \`config\` object would look like:\\n   *\\n   *  - \`onMoveShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onMoveShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponder: (e, gestureState) => \{...}\`\\n   *  - \`onStartShouldSetPanResponderCapture: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderReject: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderGrant: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderStart: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderEnd: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderRelease: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderMove: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminate: (e, gestureState) => \{...}\`\\n   *  - \`onPanResponderTerminationRequest: (e, gestureState) => \{...}\`\\n   *\\n   *  In general, for events that have capture equivalents, we update the\\n   *  gestureState once in the capture phase and can use it in the bubble phase\\n   *  as well.\\n   *\\n   *  Be careful with onStartShould* callbacks. They only reflect updated\\n   *  \`gestureState\` for start/end events that bubble/capture to the Node.\\n   *  Once the node is the responder, you can rely on every start/end event\\n   *  being processed by the gesture and \`gestureState\` being updated\\n   *  accordingly. (numberActiveTouches) may not be totally accurate unless you\\n   *  are the responder.\\n   */\\n",
      "modifiers": [
        "static"
      ],
      "params": [
        \{
          "typehint": "\{\\"type\\":\\"simple\\",\\"value\\":\\"object\\",\\"length\\":1}",
          "name": "config"
        }
      ],
      "tparams": null,
      "returntypehint": null,
      "name": "create"
    }
  ],
  "properties": [],
  "superClass": null,
  "type": "api",
  "line": 93,
  "name": "PanResponder",
  "docblock": "/**\\n * \`PanResponder\` reconciles several touches into a single gesture. It makes\\n * single-touch gestures resilient to extra touches, and can be used to\\n * recognize simple multi-touch gestures.\\n *\\n * It provides a predictable wrapper of the responder handlers provided by the\\n * [gesture responder system](/react-native/docs/gesture-responder-system.html).\\n * For each handler, it provides a new \`gestureState\` object alongside the\\n * normal event.\\n *\\n * A \`gestureState\` object has the following:\\n *\\n *  - \`stateID\` - ID of the gestureState- persisted as long as there at least\\n *     one touch on screen\\n *  - \`moveX\` - the latest screen coordinates of the recently-moved touch\\n *  - \`moveY\` - the latest screen coordinates of the recently-moved touch\\n *  - \`x0\` - the screen coordinates of the responder grant\\n *  - \`y0\` - the screen coordinates of the responder grant\\n *  - \`dx\` - accumulated distance of the gesture since the touch started\\n *  - \`dy\` - accumulated distance of the gesture since the touch started\\n *  - \`vx\` - current velocity of the gesture\\n *  - \`vy\` - current velocity of the gesture\\n *  - \`numberActiveTouches\` - Number of touches currently on screeen\\n *\\n * ### Basic Usage\\n *\\n * \`\`\`\\n *   componentWillMount: function() \{\\n *     this._panGesture = PanResponder.create(\{\\n *       // Ask to be the responder:\\n *       onStartShouldSetPanResponder: (evt, gestureState) => true,\\n *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\\n *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\\n *\\n *       onPanResponderGrant: (evt, gestureState) => \{\\n *         // The guesture has started. Show visual feedback so the user knows\\n *         // what is happening!\\n *\\n *         // gestureState.\{x,y}0 will be set to zero now\\n *       },\\n *       onPanResponderMove: (evt, gestureState) => \{\\n *         // The most recent move distance is gestureState.move\{X,Y}\\n *\\n *         // The accumulated gesture distance since becoming responder is\\n *         // gestureState.d\{x,y}\\n *       },\\n *       onPanResponderTerminationRequest: (evt, gestureState) => true,\\n *       onPanResponderRelease: (evt, gestureState) => \{\\n *         // The user has released all touches while this view is the\\n *         // responder. This typically means a gesture has succeeded\\n *       },\\n *       onPanResponderTerminate: (evt, gestureState) => \{\\n *         // Another component has become the responder, so this gesture\\n *         // should be cancelled\\n *       },\\n *     });\\n *   },\\n *\\n *   render: function() \{\\n *     return (\\n *       <View \{...this._panResponder.panHandlers} />\\n *     );\\n *   },\\n *\\n * \`\`\`\\n *\\n * ### Working Example\\n *\\n * To see it in action, try the\\n * [PanResponder example in UIExplorer](https://github.com/facebook/react-native/blob/master/Examples/UIExplorer/ResponderExample.js)\\n */\\n",
  "requires": [
    \{
      "name": "TouchHistoryMath"
    }
  ],
  "filepath": "Libraries/vendor/react/browser/eventPlugins/PanResponder.js",
  "componentName": "PanResponder",
  "example": \{
    "path": "Examples/UIExplorer/PanResponderExample.js",
    "content": "/**\\n * The examples provided by Facebook are for non-commercial testing and\\n * evaluation purposes only.\\n *\\n * Facebook reserves all rights not expressly granted.\\n *\\n * THE SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n * FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL\\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\\n * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\n *\\n * @flow\\n */\\n'use strict';\\n\\nvar React = require\('react-native');\\nvar \{\\n  StyleSheet,\\n  PanResponder,\\n  View,\\n} = React;\\n\\nvar CIRCLE_SIZE = 80;\\nvar CIRCLE_COLOR = 'blue';\\nvar CIRCLE_HIGHLIGHT_COLOR = 'green';\\n\\n\\nvar NavigatorIOSExample = React.createClass(\{\\n\\n  statics: \{\\n    title: 'PanResponder Sample',\\n    description: 'Basic gesture handling example',\\n  },\\n\\n  _panResponder: \{},\\n  _previousLeft: 0,\\n  _previousTop: 0,\\n  _circleStyles: \{},\\n  circle: (null : ?\{ setNativeProps(props: Object): void }),\\n\\n  componentWillMount: function() \{\\n    this._panResponder = PanResponder.create(\{\\n      onStartShouldSetPanResponder: this._handleStartShouldSetPanResponder,\\n      onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,\\n      onPanResponderGrant: this._handlePanResponderGrant,\\n      onPanResponderMove: this._handlePanResponderMove,\\n      onPanResponderRelease: this._handlePanResponderEnd,\\n      onPanResponderTerminate: this._handlePanResponderEnd,\\n    });\\n    this._previousLeft = 20;\\n    this._previousTop = 84;\\n    this._circleStyles = \{\\n      left: this._previousLeft,\\n      top: this._previousTop,\\n    };\\n  },\\n\\n  componentDidMount: function() \{\\n    this._updatePosition();\\n  },\\n\\n  render: function() \{\\n    return (\\n      <View\\n        style=\{styles.container}>\\n        <View\\n          ref=\{(circle) => \{\\n            this.circle = circle;\\n          }}\\n          style=\{styles.circle}\\n          \{...this._panResponder.panHandlers}\\n        />\\n      </View>\\n    );\\n  },\\n\\n  _highlight: function() \{\\n    this.circle && this.circle.setNativeProps(\{\\n      backgroundColor: CIRCLE_HIGHLIGHT_COLOR\\n    });\\n  },\\n\\n  _unHighlight: function() \{\\n    this.circle && this.circle.setNativeProps(\{\\n      backgroundColor: CIRCLE_COLOR\\n    });\\n  },\\n\\n  _updatePosition: function() \{\\n    this.circle && this.circle.setNativeProps(this._circleStyles);\\n  },\\n\\n  _handleStartShouldSetPanResponder: function(e: Object, gestureState: Object): boolean \{\\n    // Should we become active when the user presses down on the circle?\\n    return true;\\n  },\\n\\n  _handleMoveShouldSetPanResponder: function(e: Object, gestureState: Object): boolean \{\\n    // Should we become active when the user moves a touch over the circle?\\n    return true;\\n  },\\n\\n  _handlePanResponderGrant: function(e: Object, gestureState: Object) \{\\n    this._highlight();\\n  },\\n  _handlePanResponderMove: function(e: Object, gestureState: Object) \{\\n    this._circleStyles.left = this._previousLeft + gestureState.dx;\\n    this._circleStyles.top = this._previousTop + gestureState.dy;\\n    this._updatePosition();\\n  },\\n  _handlePanResponderEnd: function(e: Object, gestureState: Object) \{\\n    this._unHighlight();\\n    this._previousLeft += gestureState.dx;\\n    this._previousTop += gestureState.dy;\\n  },\\n});\\n\\nvar styles = StyleSheet.create(\{\\n  circle: \{\\n    width: CIRCLE_SIZE,\\n    height: CIRCLE_SIZE,\\n    borderRadius: CIRCLE_SIZE / 2,\\n    backgroundColor: CIRCLE_COLOR,\\n    position: 'absolute',\\n    left: 0,\\n    top: 0,\\n  },\\n  container: \{\\n    flex: 1,\\n    paddingTop: 64,\\n  },\\n});\\n\\nmodule.exports = NavigatorIOSExample;\\n"
  }
}`
var Post = React.createClass({
  render: function() {
    return layout({metadata: {"id":"panresponder","title":"PanResponder","layout":"autodocs","category":"apis","permalink":"docs/panresponder.html","next":"pixelratio"}}, content);
  }
});
Post.content = content;
module.exports = Post;
